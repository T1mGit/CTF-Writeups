This is the walkthrough for the Over the Wire - Natas levls

The login for the very first level is:
URL - http://natas0.natas.labs.overthewire.org
username : natas0
password : natas0

The Natas levels have a <div id=content> section which contains the actual challenge content.
The other div and header sections are unrelated to the challenge (at least in the low levels!!)


+++{ LEVEL 0 }+++
1) The password is found by opening the html inspector developer panel.
RMB > inspect element (F12 works in firefox)
The password is written in a comment in the html seen by expanding the html.

username: natas1
password:gtVrDuiDfck831PqWsLEZy5gyDz1clto

+++{ LEVEL 1 }+++
1) The solution is the same as level 0 but right button click is disabled.
F12 still works, or use menu

username:natas2
password:ZluruAthQk7Q2MqmDeTiUij2ZvWy2mBi

+++{ LEVEL 2 }+++
1)Open the source html browser and you'll notice a strange 1 pixel image the source of which is "files/pixel"
2)This indicates there is a directory named "files". Type this in the URL.
3) URL - http://natas2.natas.labs.overthewire.org/files - you'll discover the file "users.txt"
4) The password for natas3 is in "users.txt"

password: sJIJNW6ucpu6HPZ1ZAchaDtwd7oGrD14

+++{ LEVEL 3 }+++
1) Often web server use a file named "robots.txt" intended to stop web crawlers from indexing certain directories.
robots.txt is usually located at the root ie. /robots.txt
2) go to /robots.txt it lists a directory "Disallow:/s3cr3t/" go to the /s3cr3t/ directory.
3) there is another "users.txt" in that directory containing the password.

password:Z9tkRkWmpt9Qr7XrR5jWRkgOU901swEZ


+++{ LEVEL 4 }+++
1) Click the link to refresh the page a couple of times, you'll the following message:
[
 Access disallowed. You are visiting from "http://natas4.natas.labs.overthewire.org/"
 while authorized users should come only from "http://natas5.natas.labs.overthewire.org/"
]
2)This challeng requires a tool called "Burpsuit" or similar.
3)It is necessary to intercept the http request from the browser before it leaves our computer.
4)We need change the 'Referer Header' which is sent in the GET request.
5)The Refer Header contains the URL of the website we have come from. We have to change it to exactly the URL the challenge is asking for.
6)Change the referer header EXACTLY inlcude trailing slash and we get password

password: iX6IOfmpN7AYOQGPwtn3fXpbaJVJcHfq

+++{ LEVEL 5}+++
1) This time the challenge says:
[
 Access denied. You are not logged in.
]
2) Again with burpsuite intercept proxy - we discover a cookie with a field "loggedin=0"
3) change the value to "loggedin=1" and forward the request to get the password.

password: aGoY4q2Dc6MgDq4oL4YtoKtyAg9PeHa1

+++{ LEVEL 6 }+++
1) The challenge asks for some text input into a single field form submission.
It is supposed to be the secret code to access the next level password.
2) The server side code is provided to you.
3) Examine the server side code and see the line :

    include "includes/secret.inc";

4) The 'include' directive causes the code on the specified file to be included in the php script.
You should NOT be able to navigate to this directory - this is a directory traversal flaw.
5) Navigate to the included file: /includes/secret.inc" and look in the source explorer window to find the comment telling your the secret code that goes in the input field.

password: 7z3hEENjQtflzgnT29q7wAvMNfZdh0i9

+++{LEVEL 7}+++
1)This seems to be another directory traversal. Check the source inspector for coments. There is a hint telling you where the password is
2)If you try just navigating to the file via putting it in url: /natas_webpass/natas8
It does not work - file is not found.
3) Notice click the hyperlinks 'home' and 'about' changes url to a page parameter.
index.pgp?page=home -or- page=about
4)instead try page=/etc/natas_webpass/natas8
5)it dumps the password

password: DBfUBfqQG69KvJvJ1iAbMoIpwSNQ9bWe

+++{LEVEL 8}+++
1)Another form input. The server side is provided and gives you the encoded secret and the function which encodes
2)It is simple using php to do the reverse (decode) function.
3) Server side does this:

  $encodedSecret = "3d3d516343746d4d6d6c315669563362";

  function encodeSecret($secret) {
      return bin2hex(strrev(base64_encode($secret)));
  }

4) You need to do the reveres. PHP can be called from command line:

  php -r '$e=base64_decode(strrev(hex2bin("3d3d516343746d4d6d6c315669563362")),true); print $e;'

5) The above command will print the secret value for you: 'oubWYf2kBq'
   You need to type in to the form to get the password.

password: W0mMhUcRRnG8dcghE4qvk3JA9lGt8nDl

+++{ LEVEL 9 }+++
1)Examine the hint code. This problem suggests that its a needle in a haystack.
2)Actually it is a command execution flaw.
3)The user input goes unverified in the grep command allowing grep across arcross arbitrary files.
4)Also putting a star in the input will grep for all files in the current directory and dumps the hint code.
5)We alread know the password is located at /etc/natas_webpass/natas10 and we know the kind what the password looks like
6)We only need a single character to match grep to print the output.
7)We can try every individual letter until one matches, or we we can use a regular expression.

  -E [a-zA-Z] /etc/natas_webpass/natas10

8) -E [a-zA-Z] is the regular exprerssion
9) because we know the form of the password it wont require many guesses to match, so a regular expression is not essential

  password: nOpp1igQAkUzaI1GUUjzn1bFVj7xCNzu

+++{ LEVEL 10}+++
1)This is basically the same as LEVEL 9 but include the PHP preg_match which seems to be filtering for charters we might use in a regular expression
2)Very noticably does not filter slashes or underscore so solution fom LEVEL 9 minus the regex still works.

  U /etc/natas_webpass/natas11

3)Arbitrarily select single characters to grep for

  password: U82q5TCMMQ9xuFoI3dYX61s7OZD9JKoK


+++{ LEVEL 11 }+++
1)this problem uses xor to encrypt the cookie and there is no feed back or chaining.
2)the flaw is the use of XOR which operates byte for byte, and is reversible.
3)Given the ciphertext and the plain text the two can be XORed to produce the key.
4)We can use a php script to perform the XOR.

<?php
function get_key($plain, $crypt)
{ 
 $key=""; 
 print("Cleartext Length:".strlen($plain));
 print("\nCiphertext Length:".strlen($crypt));
 for($i=0;$i<strlen($plain);$i++){
   $key.=$plain[$i]^$crypt[$i];
  }
 return $key;
} 
$default_data=array("showpassword"=>"no", "bgcolor"=>"#ffffff");
$encoded="ClVLIh4ASCsCBE8lAxMacFMZV2hdVVotEhhUJQNVAmhSEV4sFxFeaAw%3D";
$j=json_encode($default_data);  
$x=base64_decode($encoded);
print("\nKey=".get_key($j,$x));
?>

5) Here is the output from the script

Cleartext Length:41
Ciphertext Length:42
Key=qw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jq

6)because the characters repeat it means the key is shorter than the plaintext
7)The key is: qw8J
8)We write another script to create the cookie with the injected data.

<?php
$data=json_encode(array("showpassword"=>"yes", "bgcolor"=>"#ffffff"));
$key="qw8J";   
$cookie=""; 
for($i=0;$i<strlen($data);$i++){
  $cookie.=$data[$i]^$key[$i%strlen($key)];
} 
print(base64_encode($cookie));
?>

9) The output of this script:

ClVLIh4ASCsCBE8lAxMacFMOXTlTWxooFhRXJh4FGnBTVF4sFxFeLFMK

10) this value must replace that which the server sent us.
11) the cooking can be accessed and re-written in the webbrowser (firefox) in the storage tab of the dev-tools
12) finally use the webform again, our new cookie will be sent back to the server and we get the password.

password: EDXp0pS26wLKHZy1rDBPUZk0RKfLGIR3


+++{ LEVEL 12 }+++
1) This problem wants us to upload a small size image.
2) however it does not check that an images was uploaded, or that the file was valid.
3) The uploaded file gets displayed as a hyperlink to the file.
4) clicking on the hyperlink the browser will try to request and load the file, just like an html file
5) The following issues can be exploited:
 a> The file extention is taken directly from a hidden field on client side and used in the hyperlink displayed to the user. We can change it from jpg to php.
 b> the upladed file not sanitized - we can upload a php script that will dump the password.
 c> the php script will be executed when we click on the hyperlink to the uploaded file that is displayed to us. 
6) PHP script is as follows:
 
 <html>
 <?
 $p=passthru("cat /etc/natas_webpass/natas13");
 echo $p;
 ?>
 </html>

7) Change the filename in the hidden form to have a PHP extension.
8) Upload a PHP file containing the PHP script above.
9) click the hyper link.

 Password: jmLTY0qiPZBbaKc9341cqPQZBJv7MQbY

+++{ LEVEL 13 }+++
1) The analyis of this level is exactly  the same as the previous with the addition of a magic number check
2) Most files have a signature set of bytes at the start of the file to identify them.
   The exif_imagetype function used on this level check the file signature.
3) We only need to insert an image file signture such as JFIF infront of our script used on the previos level.
4) Wikipedia the jfif file signature. Open our previous script in a Raw Hex editor and insert the signature at the start.
5) One valid Signature is FF D8 FF E0 00 10 4A 46 49 46 00 01
6) Upload the file and change the extension as done in level 12

Password: Lg96M10TdfaPyVBkJdjymbllQ5L6qdl1


+++{ LEVEL 14 }+++
1) This level is a basic SQL injection vulnerability
2) We have the following query string

   $query = "SELECT * from users where username=\"".$_REQUEST["username"]."\" and password=\"".$_REQUEST["password"]."\"";

3) User input goes directly into query with no sanitization.
4) SQL will return result when the conditions in the query evaluate to TRUE
5) because of (3) we can enter an additional SQL condition which always evaluate to TRUE
6) in the password box we type the following:
 
   " OR 1=1 #

7) quote closes the first quote in the query expression, hash is comment symbol and discards the actual closing quote, OR 1=1 is always true

Password:AwWj0w5cvxrZiONgZ9J5stNVkmxdk39J
